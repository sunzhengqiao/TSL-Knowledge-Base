{
  "filename": "hsbTSL ECS Symbol.mcr",
  "status": "completed",
  "total_tokens": 25505,
  "processing_time": 209.92633533477783,
  "passes": {
    "1": {
      "success": true,
      "data": {
        "header": {
          "type": null,
          "numBeamsReq": null,
          "keywords": null,
          "majorVersion": null,
          "minorVersion": null,
          "dxaOut": null,
          "implInsert": null
        },
        "description": "",
        "versionHistory": [
          {
            "version": "1.1",
            "date": "11.10.2017",
            "author": "th@hsbCAD.de",
            "changes": "export flag activated"
          },
          {
            "version": "1.0",
            "date": "08.09.2011",
            "author": "th@hsbCAD.de",
            "changes": "inital"
          }
        ],
        "settingsFiles": [],
        "dependencies": []
      },
      "tokens_used": 4727,
      "error": null
    },
    "2": {
      "success": true,
      "data": {
        "usageEnvironment": {
          "primarySpace": "ModelSpace",
          "supportsPaperSpace": false,
          "isShopDrawingScript": false,
          "isMultipageScript": false,
          "detectionEvidence": "Script uses getPoint() for insertion and geometric visualization functions (Display, PLine) without any sd_ prefixes, _Viewport usage, or #Type E entity references. It manipulates global coordinate system markers (_XE, _YE, _ZE) which is typically a Model Space concept for defining entity orientation."
        },
        "prerequisites": {
          "requiredEntities": [],
          "minimumBeams": 0,
          "requiredSpace": "Model Space (inserted via getPoint)",
          "requiredSettings": []
        }
      },
      "tokens_used": 2430,
      "error": null
    },
    "3": {
      "success": true,
      "data": {
        "commandLine": {
          "insertionFlow": [
            {
              "step": 1,
              "function": "getPoint",
              "promptOriginal": "",
              "condition": "_bOnInsert",
              "required": true
            }
          ],
          "keywordOptions": []
        },
        "dialogs": [],
        "opmProperties": [
          {
            "index": 0,
            "variable": "dCompassGridAngle",
            "type": "PropDouble",
            "displayName": "Grid Angle",
            "defaultValue": "15",
            "inputType": "number",
            "options": null,
            "category": null,
            "description": null
          }
        ],
        "contextMenu": [],
        "settingsFiles": []
      },
      "tokens_used": 4329,
      "error": null
    },
    "4": {
      "success": true,
      "data": {
        "scriptPurpose": {
          "summary": "Creates a visual coordinate system (ECS) marker to define a specific local orientation for elements, typically used to align views in shop drawings or define export axes.",
          "category": "ShopDrawing",
          "typicalUseCase": "Used when a component or assembly needs to be detailed in a specific rotation that differs from the global model orientation, ensuring consistent single-part drawing layouts."
        },
        "parameters": [
          {
            "name": "dCompassGridAngle",
            "technicalDefault": "15",
            "businessMeaning": "Controls the interval (in degrees) for the tick marks around the circular base of the symbol, effectively acting as a visual protractor.",
            "validRange": "1 - 90 (must divide 360 evenly)",
            "unit": "degrees",
            "affectsOutput": "Updates the frequency of radial lines on the compass circle. If the user enters a value that doesn't result in a whole number of divisions, the script automatically snaps the value to the nearest valid divisor (e.g., 14 becomes 15)."
          }
        ],
        "parameterDependencies": [
          {
            "trigger": "Changing any Grip Point (_PtG[0], _PtG[1], _PtG[2])",
            "effect": "Modifying one axis vector triggers a recalculation of the other two vectors to maintain a perfectly orthogonal coordinate system (90-degree angles between axes).",
            "cascade": [
              "_PtG",
              "_XE",
              "_YE",
              "_ZE"
            ]
          }
        ],
        "outputEntities": [
          {
            "type": "Visual Symbol / Non-Physical Entity",
            "description": "A 3D compass graphic displaying a circular grid with ticks and three colored arrows (Red/X, Green/Y, Blue/Z) representing the defined local coordinate system.",
            "appliedTo": "Model Space (inserted at _Pt0)."
          }
        ]
      },
      "tokens_used": 4087,
      "error": null
    },
    "5": {
      "success": true,
      "data": {
        "workflowDiagram": [
          "User launches script (hsbTSL ECS Symbol)",
          "Script checks if running in Insert Mode (_bOnInsert)",
          "User selects Insertion Point via getPoint()",
          "System calculates initial Grip Points based on global axes (X, Y, Z) offset from insertion point",
          "Script validates presence of at least 3 Grip Points",
          "System initializes Unit vectors (vx, vy, vz) based on Grip Point positions",
          "System checks for manual changes to specific Grips or Properties",
          "If 'Grid Angle' property modified: System adjusts angle to nearest divisor of 360",
          "If Grip Points modified: System recalculates vectors to ensure Orthogonality",
          "System renders Compass Circle and Radial Ticks",
          "System renders 3D Vector Arrows (Red X, Green Y, Blue Z)",
          "System updates internal Element Coordinate System (_XE, _YE, _ZE)",
          "Script finishes execution"
        ],
        "conditionalBranches": [
          {
            "condition": "State during Insert Cycle",
            "path1": {
              "name": "Initial Insert",
              "steps": [
                "Check if insertCycleCount > 1",
                "If yes, eraseInstance() and return (Stop duplicate insertion)",
                "If no, prompt for _Pt0 (Insertion Point)",
                "Set initial Grip Points"
              ]
            },
            "path2": {
              "name": "Recalculation/Update",
              "steps": [
                "Skip getPoint prompt",
                "Validate existing Grip Points",
                "Recalculate vectors based on current state"
              ]
            }
          },
          {
            "condition": "User modifies Grip Point 0 (X-Axis)",
            "path1": {
              "name": "X parallel to Z",
              "steps": [
                "Normalize vector X",
                "Check if Vector X is parallel to Vector Z",
                "Calculate new Vector Z (cross product of X and Y)",
                "Calculate new Vector Y (cross product of X and negative Z)"
              ]
            },
            "path2": {
              "name": "X not parallel to Z",
              "steps": [
                "Normalize vector X",
                "Calculate new Vector Y (cross product of X and negative Z)",
                "Calculate new Vector Z (cross product of X and Y)"
              ]
            }
          },
          {
            "condition": "User modifies Grip Point 1 (Y-Axis)",
            "path1": {
              "name": "Y parallel to Z",
              "steps": [
                "Normalize vector Y",
                "Check if Vector Y is parallel to Vector Z",
                "Calculate new Vector Z (cross product of X and Y)",
                "Calculate new Vector X (cross product of Y and Z)"
              ]
            },
            "path2": {
              "name": "Y not parallel to Z",
              "steps": [
                "Normalize vector Y",
                "Calculate new Vector X (cross product of Y and Z)",
                "Calculate new Vector Z (cross product of X and Y)"
              ]
            }
          },
          {
            "condition": "User modifies Grip Point 2 (Z-Axis)",
            "path1": {
              "name": "Z parallel to X",
              "steps": [
                "Normalize vector Z",
                "Check if Vector Z is parallel to Vector X",
                "Calculate new Vector X (cross product of Y and Z)",
                "Calculate new Vector Y (cross product of X and negative Z)"
              ]
            },
            "path2": {
              "name": "Z not parallel to X",
              "steps": [
                "Normalize vector Z",
                "Calculate new Vector Y (cross product of X and negative Z)",
                "Calculate new Vector X (cross product of Y and Z)"
              ]
            }
          }
        ],
        "validationRules": [
          {
            "check": "Insert Cycle Count",
            "errorMessage": "None (Silent)",
            "recovery": "Script automatically erases the current instance if it detects it is running more than once in a sequence (insertCycleCount > 1)."
          },
          {
            "check": "Grip Points Array Length",
            "errorMessage": "None (Silent)",
            "recovery": "If _PtG.length() < 3, the script resets the array to default positions based on current _Pt0 and global axes."
          },
          {
            "check": "Grid Angle Divisibility",
            "errorMessage": "None (Property auto-correction)",
            "recovery": "If dCompassGridAngle does not divide 360 evenly, the property value is automatically updated to the nearest valid angle (e.g., 14 becomes 15)."
          }
        ],
        "postInsertionActions": [
          {
            "action": "Modify Grid Angle",
            "how": "OPM Property Palette (Grid Angle)",
            "effect": "Updates the density of radial tick marks around the compass circle. Value snaps to nearest valid divisor of 360."
          },
          {
            "action": "Move Origin",
            "how": "Grip Edit (_Pt0)",
            "effect": "Relocates the entire symbol and coordinate system origin."
          },
          {
            "action": "Rotate Axes",
            "how": "Grip Edit (_PtG[0], _PtG[1], _PtG[2])",
            "effect": "Adjusts the orientation of the specific axis. The other two axes automatically recalculate to maintain orthogonality."
          },
          {
            "action": "Scale Symbol",
            "how": "Internal Variable (Script Code)",
            "effect": "The variable 'dRadius' defines the size. If modified in the script, the visual size of the compass and length of arrows change."
          }
        ]
      },
      "tokens_used": 5322,
      "error": null
    },
    "6": {
      "success": true,
      "data": {
        "markdown": "# hsbTSL ECS Symbol.mcr\n\n## Overview\nThis script inserts a visual 3D compass symbol into the model to define a specific local coordinate system (ECS). It is used to establish a custom orientation for views or export axes that differs from the global project coordinates.\n\n## Usage Environment\n| Space | Supported | Notes |\n|-------|-----------|-------|\n| Model Space | Yes | The script must be inserted in Model Space. |\n| Paper Space | No | Not supported for layout insertion. |\n| Shop Drawing | No | This is a setup tool run in the model, though it affects drawing orientations. |\n\n## Prerequisites\n- **Required entities:** None\n- **Minimum beam count:** 0\n- **Required settings files:** None\n\n## Usage Steps\n\n### Step 1: Launch Script\nCommand: `TSLINSERT` â†’ Select `hsbTSL ECS Symbol.mcr` from the file list.\n\n### Step 2: Select Insertion Point\n```\nCommand Line: [No specific text, cursor is active]\nAction: Left-click anywhere in the Model Space to place the center of the symbol.\n```\n*Note: Once placed, the symbol appears as a circular grid with three colored arrows indicating the X (Red), Y (Green), and Z (Blue) axes.*\n\n## Properties Panel Parameters\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| Grid Angle | Number | 15 | Sets the interval (in degrees) for the tick marks around the compass circle. This value automatically snaps to the nearest number that divides 360 evenly (e.g., entering 14 will correct to 15). |\n\n## Right-Click Menu Options\nThis script does not add custom options to the right-click context menu. Standard AutoCAD/hsbCAD options apply.\n\n## Settings Files\nNone required.\n\n## Tips\n- **Maintaining Orthogonality:** The symbol enforces 90-degree angles between axes. If you drag the grip point for the X-axis, the Y and Z axes will automatically rotate to remain perpendicular to it and to each other.\n- **Visual Reference:** The arrows follow the standard color coding: Red = X-axis, Green = Y-axis, and Blue = Z-axis.\n- **Adjusting Density:** Use the `Grid Angle` property to make the compass ticks finer (e.g., 5 degrees) or coarser (e.g., 45 degrees) depending on how precise you need the visual guide to be.\n- **Moving the Origin:** Use the central grip (insertion point) to relocate the entire coordinate system without changing its orientation.\n\n## FAQ\n- **Q: I typed 14 for the Grid Angle, but it changed to 15. Why?**\n  - **A:** The compass requires 360 degrees to be divided into whole segments. Since 360 divided by 14 is not a whole number, the script automatically corrects the value to 15 to ensure the grid lines align perfectly.\n- **Q: Can I skew the axes so they are not at 90 degrees?**\n  - **A:** No. This script defines a Cartesian coordinate system, which requires all three axes to be orthogonal (perpendicular) to each other. Moving one axis will always force the others to adjust.\n- **Q: How do I rotate the symbol to match a sloping roof?**\n  - **A:** Use the grip points at the tips of the arrows (Red, Green, or Blue). Dragging the tip of the Z-axis (Blue), for example, will tilt the system, and the X and Y axes will flatten out accordingly to remain horizontal relative to the new Z vector."
      },
      "tokens_used": 4610,
      "error": null
    }
  }
}